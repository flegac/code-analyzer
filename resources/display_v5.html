<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Graphe 3D avec filtre et attracteurs</title>
    <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph"></script>
    <script src="https://unpkg.com/d3-force"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #graph {
            width: 100vw;
            height: 100vh;
        }

        #legend, #filter {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 14px;
        }

        #legend {
            top: 10px;
            left: 10px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #filter {
            top: 10px;
            right: 10px;
        }
    </style>
</head>
<body>
<div id="graph"></div>
<div id="legend"><strong>Modules principaux</strong><br></div>
<div id="filter">
    <label for="search">üîç Filtrer :</label><br>
    <input type="text" id="search" placeholder="Nom du module..." style="width:200px;">
</div>

<script>
    fetch('depends_on.json')
        .then(res => res.json())
        .then(data => {
            const nodes = [];
            const links = [];
            const colorMap = {};
            const palette = [
                '#e6194b', '#3cb44b', '#ffe119', '#4363d8',
                '#f58231', '#911eb4', '#46f0f0', '#f032e6',
                '#bcf60c', '#fabebe', '#008080', '#e6beff'
            ];

            const usedBy = {};
            Object.entries(data).forEach(([source, targets]) => {
                targets.forEach(target => {
                    if (!usedBy[target]) usedBy[target] = [];
                    usedBy[target].push(source);
                    links.push({source, target});
                });
            });

            const rootList = [];
            Object.keys(data).forEach(id => {
                const root = id.split('.').slice(0, 2).join('.');
                if (!colorMap[root]) {
                    colorMap[root] = palette[rootList.length % palette.length];
                    rootList.push(root);
                }

                const inDegree = usedBy[id]?.length || 0;
                const outDegree = data[id]?.length || 0;
                let y = 0;
                if (inDegree > 3 && outDegree === 0) y = -200;
                else if (outDegree > 3 && inDegree === 0) y = 200;
                else if (inDegree > 2 && outDegree > 2) y = 0;
                else if (inDegree === 0 && outDegree <= 2) y = -100;
                else y = 100;

                const x = rootList.indexOf(root) * 150;

                nodes.push({
                    id,
                    group: root,
                    color: colorMap[root],
                    x, y, z: Math.random() * 50,
                    filtered: false
                });
            });

            // L√©gende
            const legend = document.getElementById('legend');
            rootList.forEach(root => {
                const color = colorMap[root];
                const item = document.createElement('div');
                item.innerHTML = `<span style="display:inline-block;width:12px;height:12px;background:${color};margin-right:5px;"></span>${root}`;
                legend.appendChild(item);
            });

            // Graph rendering
            const Graph = ForceGraph3D()(document.getElementById('graph'))
                .graphData({nodes, links})
                .nodeLabel('id')
                .nodeColor(node => node.filtered ? darkenColor(node.color) : node.color)
                .nodeThreeObject(node => {
                    const geometry = new THREE.SphereGeometry(node.filtered ? 2 : 6);
                    const material = new THREE.MeshBasicMaterial({color: node.filtered ? darkenColor(node.color) : node.color});
                    return new THREE.Mesh(geometry, material);
                })
                .linkColor(() => '#ccc')
                .linkDirectionalArrowLength(3)
                .linkDirectionalParticles(2)
                .onNodeClick(node => alert(`Module : ${node.id}`))
                .forceEngine('d3')
                .d3Force('charge', null);

            // Attracteurs par cluster
            const attractors = {};
            rootList.forEach((root, i) => {
                attractors[root] = i * 150;
            });

            Graph.d3Force('x', d3.forceX(node => attractors[node.group]).strength(0.2));
            Graph.d3Force('y', d3.forceY(node => node.y).strength(0.2));
            Graph.d3Force('z', () => {
                return {
                    initialize: () => {
                    },
                    strength: () => 0.01,
                    apply: nodes => {
                        nodes.forEach(node => {
                            node.vz += (0 - node.z) * 0.01;
                        });
                    }
                };
            });


            // Axes X, Y, Z
            const axes = [
                {dir: [1, 0, 0], color: 'red'},
                {dir: [0, 1, 0], color: 'green'},
                {dir: [0, 0, 1], color: 'blue'}
            ];
            axes.forEach(({dir, color}) => {
                Graph.scene().add(new THREE.ArrowHelper(
                    new THREE.Vector3(...dir),
                    new THREE.Vector3(0, 0, 0),
                    300,
                    color
                ));
            });

            // Filtrage
            document.getElementById('search').addEventListener('input', e => {
                const query = e.target.value.toLowerCase();
                nodes.forEach(node => {
                    node.filtered = !node.id.toLowerCase().includes(query);
                });
                Graph.nodeColor(node => node.filtered ? darkenColor(node.color) : node.color);
                Graph.nodeThreeObject(node => {
                    const geometry = new THREE.SphereGeometry(node.filtered ? 2 : 6);
                    const material = new THREE.MeshBasicMaterial({color: node.filtered ? darkenColor(node.color) : node.color});
                    return new THREE.Mesh(geometry, material);
                });
            });

            function darkenColor(hex) {
                const c = parseInt(hex.slice(1), 16);
                const r = Math.floor((c >> 16) * 0.3);
                const g = Math.floor(((c >> 8) & 255) * 0.3);
                const b = Math.floor((c & 255) * 0.3);
                return `rgb(${r},${g},${b})`;
            }
        });
</script>
</body>
</html>
