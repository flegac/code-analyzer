<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Visualisation 3D du Graphe</title>
    <script src="https://unpkg.com/3d-force-graph"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #graph {
            width: 100vw;
            height: 100vh;
        }

        #legend, #controls {
            position: absolute;
            background: rgba(255, 255, 255, 0.85);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 14px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #legend {
            top: 200px;
            right: 10px;
        }

        #treeview {
            position: absolute;
            left: 10px;
            top: 10px;
            width: 250px;
            max-height: 60vh;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.85);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 14px;
        }

        #treeview ul {
            margin: 0;
            padding-left: 1em;
            list-style: none;
        }

        /* Par d√©faut, on cache toutes les sous-listes */
        #treeview li ul {
            display: none;
        }

        /* Quand un <li> porte la classe expanded, on montre sa sous-liste */
        #treeview li.expanded > ul {
            display: block;
        }

        /* Style du libell√© pour indiquer la cliquabilit√© */
        #treeview .tree-label {
            cursor: pointer;
            user-select: none;
            display: inline-block;
        }

        /* Fl√®ches avant le texte : ‚ñ∫ pour ferm√©, ‚ñº pour ouvert, rien pour une feuille */
        #treeview .tree-label::before {
            content: "‚ñ∫";
            display: inline-block;
            width: 1em;
        }

        #treeview li.expanded > .tree-label::before {
            content: "‚ñº";
        }

        #treeview li.leaf > .tree-label::before {
            content: "";
        }


        #controls {
            top: 10px;
            right: 10px;
        }
    </style>
</head>
<body>
<div id="graph"></div>
<div id="legend"><strong>Modules principaux</strong><br></div>
<div id="treeview"><strong>Arborescence des modules</strong></div>
<div id="controls">
    <label for="dataSelect">Fichier JSON :</label><br>
    <select id="dataSelect">
        <option value="graph.json">graph.json</option>
        <option value="modules.json">modules.json</option>
        <option value="dependencies.json">dependencies.json</option>
        <option value="example.json">example.json</option>
    </select><br><br>

    <label for="depthSelect">Profondeur du pr√©fixe :</label><br>
    <select id="depthSelect">
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="2" selected>2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
    </select><br><br>

    <button id="reloadBtn">üîÑ Recharger</button>
</div>

<script>
    let graphInstance = null;

    const VizConfig = {
        palette: [
            '#e6194b', '#3cb44b', '#ffe119', '#4363d8',
            '#f58231', '#911eb4', '#46f0f0', '#f032e6',
            '#bcf60c', '#fabebe', '#008080', '#e6beff'
        ]
    };

    class ColorStrategy {
        constructor(config) {
            this.palette = config.palette;
            this.prefixDepth = config.modulePrefixDepth;
            this.colorMap = {};
            this.prefixOrder = [];
        }

        getModulePrefix(id) {
            return id.split('.').slice(0, this.prefixDepth).join('.');
        }

        assignColors(modules) {
            const seen = new Set();
            for (const id of modules) {
                const prefix = this.getModulePrefix(id);
                if (!seen.has(prefix)) {
                    seen.add(prefix);
                    this.prefixOrder.push(prefix);
                    this.colorMap[prefix] = this.palette[(this.prefixOrder.length - 1) % this.palette.length];
                }
            }
        }

        getColor(id) {
            const prefix = this.getModulePrefix(id);
            return this.colorMap[prefix] || '#999';
        }

        getColorIndex(id) {
            const prefix = this.getModulePrefix(id);
            return this.prefixOrder.indexOf(prefix);
        }

        getColorMap() {
            return this.colorMap;
        }
    }

    class TreeView {
        /**
         * @param {string[]} modules  Liste de tous les modules (id complets)
         * @param {number} depth      Profondeur souhait√©e pour l'arborescence
         */
        constructor(modules, depth) {
            this.modules = modules;
            this.depth = depth;
            this.tree = {name: 'root', children: []};
            this._build();
        }

        /**
         * Construit l'arbre en regroupant par pr√©fixe jusqu'√† la profondeur donn√©e.
         */
        _build() {
            for (const fullId of this.modules) {
                const segments = fullId.split('.');
                let cursor = this.tree;

                // It√®re sur chaque niveau jusqu'√† `depth`
                for (let level = 0; level < this.depth; level++) {
                    const key = segments[level] || '(vide)';
                    let child = cursor.children.find(n => n.name === key);

                    if (!child) {
                        child = {name: key, children: []};
                        cursor.children.push(child);
                    }
                    cursor = child;
                }

                // √Ä la profondeur max, on ajoute la ‚Äúfeuille‚Äù portant le reste du nom
                const remainder = segments.slice(this.depth).join('.');
                cursor.children.push({
                    name: remainder || segments[this.depth - 1] || fullId,
                    fullName: fullId
                });
            }
        }

        /**
         * Retourne la structure arborescente.
         * @returns {{ name: string, children: any[] }}
         */
        getTree() {
            return this.tree;
        }
    }

    class Graph {
        constructor(data, colorStrategy) {
            this.data = data;
            this.colorStrategy = colorStrategy;
            this.nodes = [];
            this.links = [];
            this.usedBy = {};
            this.build();
        }

        computeNodePosition(inDegree, outDegree, colorIndex) {
            return {
                x: colorIndex * 10,
                y: Math.random() * 100,
                z: Math.random() * 100
            };
        }

        build() {
            for (const [source, targets] of Object.entries(this.data)) {
                for (const target of targets) {
                    if (!this.usedBy[target]) this.usedBy[target] = [];
                    this.usedBy[target].push(source);
                    this.links.push({source, target, curvature: 0.2});
                }
            }

            this.colorStrategy.assignColors(Object.keys(this.data));

            for (const id of Object.keys(this.data)) {
                const outDegree = this.data[id]?.length || 0;
                const inDegree = this.usedBy[id]?.length || 0;
                const color = this.colorStrategy.getColor(id);
                const colorIndex = this.colorStrategy.getColorIndex(id);

                this.nodes.push({
                    id,
                    group: this.colorStrategy.getModulePrefix(id),
                    color,
                    ...this.computeNodePosition(inDegree, outDegree, colorIndex)
                });
            }
        }

        getGraphData() {
            return {
                nodes: this.nodes,
                links: this.links,
                colorMap: this.colorStrategy.getColorMap()
            };
        }
    }

    class GraphRenderer {
        constructor(containerId, legendId) {
            this.container = document.getElementById(containerId);
            this.legend = document.getElementById(legendId);
        }

        renderLegend(colorMap) {
            this.legend.innerHTML = '<strong>Modules principaux</strong><br>';
            for (const [mod, color] of Object.entries(colorMap)) {
                const item = document.createElement('div');
                item.innerHTML = `<span style="display:inline-block;width:12px;height:12px;background:${color};margin-right:5px;"></span>${mod}`;
                this.legend.appendChild(item);
            }
        }

        renderGraph({nodes, links}) {
            // Nettoyer l'ancienne instance si elle existe
            if (graphInstance && typeof graphInstance._destructor === 'function') {
                graphInstance._destructor(); // m√©thode interne pour lib√©rer les ressources
            }

            // Cr√©er une nouvelle instance
            graphInstance = ForceGraph3D()(this.container)
                .graphData({nodes, links})
                .nodeLabel('id')
                .nodeColor('color')
                .linkCurvature('curvature')
                .linkDirectionalParticles(2)
                .linkDirectionalArrowLength(3)
                .linkDirectionalArrowColor(() => '#999')
                .linkColor(() => '#ccc')
                .onNodeClick(node => alert(`Module : ${node.id}`));
        }
    }

    function renderTree(node, container) {
        const ul = document.createElement('ul');
        container.appendChild(ul);

        for (const child of node.children || []) {
            const li = document.createElement('li');
            const label = document.createElement('span');

            label.textContent = child.name;
            label.classList.add('tree-label');
            li.appendChild(label);

            // Si le n≈ìud n'a pas d'enfants, taguez-le comme feuille
            if (!child.children || child.children.length === 0) {
                li.classList.add('leaf');
            }

            ul.appendChild(li);

            // Si le n≈ìud a des enfants, on cr√©e r√©cursivement la sous-liste
            if (child.children && child.children.length > 0) {
                renderTree(child, li);

                // Au clic, on bascule la classe 'expanded' pour montrer/masquer
                label.addEventListener('click', () => {
                    li.classList.toggle('expanded');
                });
            }
        }
    }

    async function loadGraph() {
        const dataPath = document.getElementById('dataSelect').value;
        const modulePrefixDepth = parseInt(document.getElementById('depthSelect').value, 10);

        try {
            const rawData = await fetch(dataPath).then(res => res.json());

            // 1. R√©cup√©rer l'ensemble des modules (cl√© + cibles)
            const moduleSet = new Set(Object.keys(rawData));
            Object.values(rawData).forEach(arr => arr.forEach(id => moduleSet.add(id)));
            const allModules = Array.from(moduleSet);

            // 2. Construire et r√©cup√©rer l'arbre
            const treeView = new TreeView(allModules, modulePrefixDepth);
            const treeData = treeView.getTree();


            // Apr√®s avoir construit `treeData` :
            const treeContainer = document.getElementById('treeview');
            treeContainer.innerHTML = '<strong>Arborescence des modules</strong>';
            renderTree(treeData, treeContainer);

            console.log('Structure arborescente des modules :', treeData);
            // ‚Üí vous pouvez ensuite passer `treeData` √† un composant UI d'arborescence,
            //    l'afficher dans une <ul> / <ol>, ou tout autre rendu.

            // 3. Continuer le rendu 3D comme avant...
            const config = {...VizConfig, modulePrefixDepth};
            const colorStrategy = new ColorStrategy(config);
            const graph = new Graph(rawData, colorStrategy);
            const renderer = new GraphRenderer('graph', 'legend');

            const graphData = graph.getGraphData();
            renderer.renderLegend(graphData.colorMap);
            renderer.renderGraph(graphData);

        } catch (err) {
            alert("Erreur lors du chargement du fichier JSON : " + err.message);
        }
    }

    document.getElementById('reloadBtn').addEventListener('click', loadGraph);

    // Initialisation
    window.addEventListener('DOMContentLoaded', loadGraph);
</script>
</body>
</html>
